# the working directory
workdir: /scratch/VST_J0248_for_new_pipeline/
# where to find new images
raw_dirs:
  - /scratch/VST_J0248_for_new_pipeline/raw
  - /scratch/VST_J0248_for_new_pipeline/raw_2
# redo flag, used by most processes
redo: 0
# for logging
log_directory: /tmp/logs
# some processes can be parallelized
multiprocessing_cpu_count: 4

# now we define our Region of Interest (ROI)
# the ROI will be extracted, and have flux calibrated cutouts prepared.
ROI:
  J0248+1913: 
    coordinates: [42.2031, 19.22528]  # [ra, dec] in degrees
    cutout_size: 50  # in pixels
# the ROI will be used as a position starting point for the plate solving.

# telescope information:
telescope:
  name: VST
  longitude: -70.4
  latitude: -24.6
  elevation: 2635.0
  imager_name: OmegaCAM

# do plots of extracted sources?
source_extraction_do_plots: 1
# trimming the images upon importation, in pixels
trim_vertical: 1200
trim_horizontal: 200

# are your images already plate solved? if yes, we will skip the plate solving step 
already_plate_solved: 0
# plate solving strategy: plate solve all, or plate solve one and align the others 
# onto the first one.
# possibilities: 'plate_solve_all', 'plate_solve_then_align'
# I recommend the first one, it'll be a bit slower ...but also more robust to
# variations in the pointing.
plate_solving_strategy: 'plate_solve'

# this is a plate scale interval to speed up the plate solving, 
# you can make it more precise if you know the plate scale of your instrument. 
# In arcseconds per pixel.
plate_scale_interval: [0.19, 0.23]

# now for the plate solving, we are going to use my wrapper around Astrometry.net:
# widefield_plate_solver
# It can either use a local installation (solve-field command in path)
# or the astrometry.net api. We will try to use the local installation
# if the astrometry api key below is null.
# else we'll use the API.
astrometry_net_api_key: null

# now the calibration stars selection.
# we can either focus on the footprint common to all images, the idea being stability across
# epochs in both the PSF model and normalization coefficient.
# only works with stable pointings obviously.
# param name: 'common_footprint_stars'
# The other possibility is looking for stars close to the ROI: ROI_disk
# third possibility, we do not care about the footprints and simply select the best 
# stars in each image, with a preference for being close to the ROI at later stages.
# param name: 'stars_per_frame'
# the latter is prefered when you're desperate for stars, querying a much larger footprint.
# in summary: 'common_footprint_stars', or 'ROI_disk', or 'stars_per_frame'.
star_selection_strategy: 'ROI_disk'
# if the above is 'ROI_disk', provide here the radius in arcseconds:
ROI_disk_radius_arcseconds: 160
# now the stars, depending on your setup you will need to probe a different range
# of magnitudes to both provide high S/N constraints to your normalization and PSF models,
# while avoiding saturation -- set to null for no contraints
star_min_gmag: 16.5
star_max_gmag: 19.0
# we discard stars that were not well fitted by a point source solution in gaia
# (could be galaxies, or very crowded fields, or doubles ...which we need to avoid)
# set to null for no constraints
star_max_astrometric_excess_noise: 2.0
# finally, we can also request a small photometric error,
# as the photometric error will go up with variability. this way we can select
# more stable stars.
star_max_phot_g_mean_flux_error: 2.0
# number criterion
min_number_stars: 4
# and whether we query again ... please set it to true should you need to change the footprint type
gaia_query_redo: false

# each good star is then named with a single letter, by ascending distance from the ROI.
# if more than 26, names will include 'aa', 'ab', etc. --> then switch to a list instead of a string.
# these stars will be used for the PSF model and normalization.
# if null: uses the top 10 closest star to the ROI.
stars_to_use_psf: null
stars_to_use_norm: 'abcd'

# Stamp extraction
stamp_size_stars: 32
stamp_size_ROI: 64
redo_stamp_extraction: false


# PSF modelling
redo_psf: false
subsampling_factor: 2
psf_n_iter_analytic: 60
psf_n_iter_pixels: 3000

# general preparation beyond PSF.
# we'll have a nice chi2 value for each PSF fit.
# we can filter the bad fit by comparing the chi2 values.
# so, psf_fit_exclude_strategy: 'null', or 'sigma_clip' 
# so, first one would look like:
#psf_fit_exclude_strategy: null  # not excluding anything
# second one:
psf_fit_exclude_strategy: 
    sigma_clip: 4 # from how many sigma from the median do we exclude?
# and a final one:
#psf_fit_exclude_strategy:
#    threshold: [0, 1.5] # range of values of chi2 that we keep.
# uncomment one of them.

# star photometry
redo_star_photometry: true
star_deconv_n_iter: 1000
